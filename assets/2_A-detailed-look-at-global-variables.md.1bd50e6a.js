import{_ as s,c as l,o as a,N as n}from"./chunks/framework.6cc0e97a.js";const e="/deep-javascript-cn/assets/global-environment.bf6827ee.jpg",A=JSON.parse('{"title":"全局变量和全局环境","description":"","frontmatter":{"title":"全局变量和全局环境"},"headers":[{"level":2,"title":"1️⃣ 作用域","slug":"_1️⃣-作用域","link":"#_1️⃣-作用域","children":[]},{"level":2,"title":"2️⃣ 词法环境","slug":"_2️⃣-词法环境","link":"#_2️⃣-词法环境","children":[]},{"level":2,"title":"3️⃣ 全局对象","slug":"_3️⃣-全局对象","link":"#_3️⃣-全局对象","children":[]},{"level":2,"title":"4️⃣ 在浏览器中，globalThis 不直接指向全局对象","slug":"_4️⃣-在浏览器中-globalthis-不直接指向全局对象","link":"#_4️⃣-在浏览器中-globalthis-不直接指向全局对象","children":[]},{"level":2,"title":"5️⃣ 全局环境","slug":"_5️⃣-全局环境","link":"#_5️⃣-全局环境","children":[{"level":3,"title":"5.1 脚本作用域和模块作用域","slug":"_5-1-脚本作用域和模块作用域","link":"#_5-1-脚本作用域和模块作用域","children":[]},{"level":3,"title":"5.2 创建变量：声明式记录 vs. 对象记录","slug":"_5-2-创建变量-声明式记录-vs-对象记录","link":"#_5-2-创建变量-声明式记录-vs-对象记录","children":[]},{"level":3,"title":"5.3 获取或设置变量","slug":"_5-3-获取或设置变量","link":"#_5-3-获取或设置变量","children":[]},{"level":3,"title":"5.4 全局ECMAScript变量 和 全局宿主变量","slug":"_5-4-全局ecmascript变量-和-全局宿主变量","link":"#_5-4-全局ecmascript变量-和-全局宿主变量","children":[]}]},{"level":2,"title":"6️⃣ 总结：为什么JS同时拥有普通全局变量和全局对象？","slug":"_6️⃣-总结-为什么js同时拥有普通全局变量和全局对象","link":"#_6️⃣-总结-为什么js同时拥有普通全局变量和全局对象","children":[]},{"level":2,"title":"7️⃣ 进一步阅读和本章来源","slug":"_7️⃣-进一步阅读和本章来源","link":"#_7️⃣-进一步阅读和本章来源","children":[]}],"relativePath":"2/A-detailed-look-at-global-variables.md","lastUpdated":1678784865000}'),o={name:"2/A-detailed-look-at-global-variables.md"},p=n(`<p>目录：</p><nav class="table-of-contents"><ul><li><a href="#_1️⃣-作用域">1️⃣ 作用域</a></li><li><a href="#_2️⃣-词法环境">2️⃣ 词法环境</a></li><li><a href="#_3️⃣-全局对象">3️⃣ 全局对象</a></li><li><a href="#_4️⃣-在浏览器中-globalthis-不直接指向全局对象">4️⃣ 在浏览器中，globalThis 不直接指向全局对象</a></li><li><a href="#_5️⃣-全局环境">5️⃣ 全局环境</a><ul><li><a href="#_5-1-脚本作用域和模块作用域">5.1 脚本作用域和模块作用域</a></li><li><a href="#_5-2-创建变量-声明式记录-vs-对象记录">5.2 创建变量：声明式记录 vs. 对象记录</a></li><li><a href="#_5-3-获取或设置变量">5.3 获取或设置变量</a></li><li><a href="#_5-4-全局ecmascript变量-和-全局宿主变量">5.4 全局ECMAScript变量 和 全局宿主变量</a></li></ul></li><li><a href="#_6️⃣-总结-为什么js同时拥有普通全局变量和全局对象">6️⃣ 总结：为什么JS同时拥有普通全局变量和全局对象？</a></li><li><a href="#_7️⃣-进一步阅读和本章来源">7️⃣ 进一步阅读和本章来源</a></li></ul></nav><p>本章将详细的看一看JS全局变量是如何工作的。几个有趣的现象扮演着重要的角色：脚本作用域，所谓的 <em>全局对象（<code>global object</code>）</em> 以及其它。</p><p id="1"></p><h2 id="_1️⃣-作用域" tabindex="-1">1️⃣ 作用域 <a class="header-anchor" href="#_1️⃣-作用域" aria-hidden="true">#</a></h2><p>📚一个变量的词法作用域（<code>lexical scope</code>, 简称 <code>scope</code>） 是一个程序能访问到的区域。JS作用域是<em>静态的</em>（在运行时不会改变），并且作用域可以进行嵌套：🌰</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line highlighted"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">func</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// A</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">aVariable</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line highlighted"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">     </span><span style="color:#676E95;font-style:italic;">// B</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anotherVariable</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><code>if</code> 语句（B行）产生的作用域嵌套在函数 <code>func()</code> (A行) 中。</p><p>包裹在 <code>S</code> 作用域称外的作用域称之为S的 <strong>外部作用域（<code>outer scope</code>）</strong>，上例中 <code>func</code> 便是 <code>if</code> 的外部作用域。</p><p id="2"></p><h2 id="_2️⃣-词法环境" tabindex="-1">2️⃣ 词法环境 <a class="header-anchor" href="#_2️⃣-词法环境" aria-hidden="true">#</a></h2><p>在JS语言规范中，作用域通过 <em>词法环境（<code>lexical environments</code>）</em> 实现。由2个组件组成：</p><ul><li>一个 <em>环境记录（<code>environment record</code>）</em> 将变量名映射到变量值（可理解为字典）。这是该作用域中存储变量的实际存储空间。记录中的 <code>name-value</code> 条目（<code>entries</code>）称之为 <em>绑定（<code>bindings</code>）</em></li><li>一个 <em>外部环境（<code>outer environment</code>）</em> 的引用：外部作用域的环境</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>👩🏻‍🏫 因此，嵌套作用域树通过外部环境引用的环境树表示（The tree of nested scopes is therefore represented by a tree of environments linked by outer environment references）。</p></div><p id="3"></p><h2 id="_3️⃣-全局对象" tabindex="-1">3️⃣ 全局对象 <a class="header-anchor" href="#_3️⃣-全局对象" aria-hidden="true">#</a></h2><p>全局对象是指其属性变为全局变量的对象（我们将稍后检查它如何准确地适合环境树。）。它可以通过以下全局变量被访问：</p><ul><li>所有平台都能访问： <a href="https://exploringjs.com/impatient-js/ch_variables-assignment.html#globalThis" target="_blank" rel="noreferrer">globalThis</a>。这个名字的由来基于它和全局作用于下的 <code>this</code> 拥有相同的值的事实。</li><li>其它全局对象不是所有平台都存在： <ul><li><code>window</code> 是引用全局对象的经典方式。它在浏览器代码中运行正常，但是不支持 <em>Web Workers（和浏览器进程并行运行的进程）</em> 和 Node.js</li><li><code>self</code> 在浏览器环境（包括Web Workers）中都可以访问，但不支持Node.js</li><li><code>global</code> 只存在于Node.js 中</li></ul></li></ul><p id="4"></p><h2 id="_4️⃣-在浏览器中-globalthis-不直接指向全局对象" tabindex="-1">4️⃣ 在浏览器中，globalThis 不直接指向全局对象 <a class="header-anchor" href="#_4️⃣-在浏览器中-globalthis-不直接指向全局对象" aria-hidden="true">#</a></h2><p>在浏览器中，<code>globalThis</code> 不直接指向全局对象，存在一个间接性。示例，想象一下web页面中的 <code>iframe</code>:</p><ul><li>当iframe的 <code>src</code> 发生变化时，它将获取一个全新的全局对象</li><li>然而，<code>globalThis</code> 总是相同的值。该值可在iframe外部进行检验，示例如下（示例灵感来源于 <a href="https://github.com/tc39/proposal-global#html-and-the-windowproxy" target="_blank" rel="noreferrer">an example in the globalThis proosal</a>）</li></ul><p><code>parent.html</code>文件：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">iframe</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">iframe.html?first</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">iframe</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">scirpt</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  const iframe = document.querySelector(&#39;iframe&#39;)</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  const icw = iframe.contentWindow // iframe的 &#39;globalThis&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  iframe.onload = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  // 访问iframe全局对象上的属性</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">    const firstGlobalThis = icw.globalThis</span></span>
<span class="line"><span style="color:#A6ACCD;">    const firstArray = icw.Array  // 全局对象 Array</span></span>
<span class="line"><span style="color:#A6ACCD;">    console.log(icw.iframeName) // &#39;first&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">    iframe.onload = () =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">      const secondGlobalThis = icw.globalThis</span></span>
<span class="line"><span style="color:#A6ACCD;">      const secondArray = icw.Array</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">      // 全局对象是不同的</span></span>
<span class="line"><span style="color:#A6ACCD;">      console.log(icw.iframeName) // &#39;second&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">      console.log(secondArray === firstArray) // false</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">      // 但是 globalThis 仍一样</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">      console.log(firstGlobalThis === secondGlobalThis) // true 🤩</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    // 改变iframe src</span></span>
<span class="line"><span style="color:#A6ACCD;">    iframe.src = &#39;iframe.html?second&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">scirpt</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p><code>iframe.html</code> 文件：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  globalThis</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">iframeName </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">search</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">slice</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>👩🏻‍🏫 浏览器是如何确保 <code>globalThis</code> 这种情况下仍不改变的呢？浏览器内部对这2个对象进行了区分：</p><ul><li><a href="https://html.spec.whatwg.org/multipage/window-object.html#the-window-object" target="_blank" rel="noreferrer">Window</a> 是全局对象，<strong>当location发生变化时，它也跟着发生变化 📚</strong>（译者注：这也是为什么微前端中调用window.reload()是最硬核的隔离的原因）</li><li><a href="https://html.spec.whatwg.org/multipage/window-object.html#the-windowproxy-exotic-object" target="_blank" rel="noreferrer">WindowProxy</a> 是将所有访问转发到当前 <code>Window</code> 的一个对象。<strong>这个对象永远不会改变 😎</strong></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>📚 在<strong>浏览器</strong>中，<code>globalThis</code> 指向 <code>WindowProxy</code>；则其余环境中，它直接指向全局对象。</p></div><p id="5"></p><h2 id="_5️⃣-全局环境" tabindex="-1">5️⃣ 全局环境 <a class="header-anchor" href="#_5️⃣-全局环境" aria-hidden="true">#</a></h2><p>全局作用域是最外层（<code>outermost</code>）的作用域 - 它上面没有外层作用域了。它的环境是 <em>全局环境（<code>global environment</code>）</em>。每个环境都通过由外部环境引用链接的环境链与全局环境连接，全局环境的外部环境引用是 <code>null</code>。（译者注：类似原型链的机制）</p><p>💡全局环境记录使用2个环境记录管理其变量：</p><ol><li>一个 <em>对象环境记录（<code>object environment record</code>）</em>,它和普通环境记录使用相同的接口，但是将其<em>绑定（<code>bindings</code>）</em> 保存在JS对象中。这种情况下，该对象为全局对象。</li><li>一个 <em>普通（声明式）环境记录（<code>normal (declarative) environment</code>）</em> 拥有自己存储绑定的空间 😎</li></ol><p>这两个记录中的哪一个在什么时候使用，稍后会解释。</p><p id="5.1"></p><h3 id="_5-1-脚本作用域和模块作用域" tabindex="-1">5.1 脚本作用域和模块作用域 <a class="header-anchor" href="#_5-1-脚本作用域和模块作用域" aria-hidden="true">#</a></h3><p>在JS中，只有最上层的脚本（<code>scripts</code>） 在全局作用域中。相比之下，每个模块都拥有自己的作用域，它们是脚本作用域的子作用域。</p><p>如果我们忽略变量绑定如何添加到全局环境的复杂规则，全局作用域和模块作用域工作原理就好像下面嵌套代码块一样：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 全局作用域 （所有脚本的作用域）</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// （全局变量）</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 模块1作用域</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 模块2作用域</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// (更多模块作用域)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p id="5.2"></p><h3 id="_5-2-创建变量-声明式记录-vs-对象记录" tabindex="-1">5.2 创建变量：声明式记录 vs. 对象记录 <a class="header-anchor" href="#_5-2-创建变量-声明式记录-vs-对象记录" aria-hidden="true">#</a></h3><p>📚 为了创建一个真正的全局变量，我们必须在全局作用域中：即在最上层的脚本（<code>scirpts</code>）中:</p><ul><li>顶层 <code>const &amp; let</code> &amp; <code>class</code> 在声明式环境记录（<code>declarative environment record</code>）中创建绑定</li><li>顶层 <code>var</code> &amp; <code>function</code>声明 在对象环境记录中创建绑定</li></ul><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> one </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 声明式环境记录中创建绑定</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> two </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 对象环境记录中创建绑定</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 所有脚本共享相同的最上层作用域</span></span>
<span class="line"><span style="color:#A6ACCD;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(one) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#A6ACCD;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(two) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line highlighted"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 并非所有声明都创建全局对象的属性 🤔</span></span>
<span class="line"><span style="color:#A6ACCD;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(globalThis</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">one) </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(globalThis</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">two) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p id="5.3"></p><h3 id="_5-3-获取或设置变量" tabindex="-1">5.3 获取或设置变量 <a class="header-anchor" href="#_5-3-获取或设置变量" aria-hidden="true">#</a></h3><p>当我们获取或者设置一个变量，2个环境记录中都存在该变量的绑定时，声明式记录获胜😎：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> myGlobalVariable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 声明式环境记录</span></span>
<span class="line"><span style="color:#A6ACCD;">  global</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">myGlobalVaribale </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 对象环境记录</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(myGlobalVariable) </span><span style="color:#676E95;font-style:italic;">// 1 (声明式环境记录获胜 ✌️)</span></span>
<span class="line"><span style="color:#A6ACCD;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(globalThis</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">myGlobalVariable) </span><span style="color:#676E95;font-style:italic;">// 2 (从对象环境记录中获取)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p id="5.4"></p><h3 id="_5-4-全局ecmascript变量-和-全局宿主变量" tabindex="-1">5.4 全局ECMAScript变量 和 全局宿主变量 <a class="header-anchor" href="#_5-4-全局ecmascript变量-和-全局宿主变量" aria-hidden="true">#</a></h3><p>除了通过 <code>var</code> 或者 函数声明 创建的变量外，全局变量包含以下属性：</p><ul><li>ECMAScript所有内置的全局变量（比如 <code>Math</code>）</li><li>所有宿主平台（浏览器，Node.js等等）内置全局变量（比如 <code>global</code> | <code>window</code>）</li></ul><p>使用 <code>const | let</code> 可确保全局变量声明不受内置的ECMAScript &amp; 宿主全局变量影响或者影响到内置的ECMAScript &amp; 宿主全局变量。</p><p>比如：浏览器有一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location" target="_blank" rel="noreferrer">location</a> 全局变量：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 将改变当前document的location（直接跳转到该地址）</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> location </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">https://example.com</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 屏蔽 window.location, 但是不会改变它</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> location </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">https://example.com</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div><p>如果一个变量已经存在（比如这里的 <code>location</code>）, 则带有初始化器的<code>var</code> 声明表现得就像是赋值。这也是为什么我们这个例子会遇到麻烦。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>👩🏻‍🏫 注意这只会在全局作用域中会存在问题。在模块中，我们永远不会在全局作用域中（除非使用类似 <code>eval()</code> 方法）。</p></div><p>总结目前所学到的：</p><p><img src="`+e+'" alt="global-environment"></p><ol><li>全局作用域的环境通过一个 <strong>全局环境记录（<code>Global environment record</code>）</strong> 管理其绑定</li><li>而 <em>全局环境记录</em> 又由2个环境记录组成： <ol><li><em>对象环境记录（<code>Object environment record</code>）</em> 将绑定存储在全局对象（<code>Global object</code>）上</li><li><em>声明式环境记录（<code>Declarative environment record</code>）</em> 使用自己内部存储记录其绑定</li></ol></li><li>因此，全局变量可以通过向全局对象添加属性或者通过各种声明（<code>var</code> | 函数声明）进行创建</li><li>全局对象的初始化包含ECMAScript全局变量和宿主平台提供的全局变量</li><li>每个ECMAScript模块（即 <code>ESM</code>）都拥有自己独立的环境，模块的外部环境是全局环境</li></ol><p id="6"></p><h2 id="_6️⃣-总结-为什么js同时拥有普通全局变量和全局对象" tabindex="-1">6️⃣ 总结：为什么JS同时拥有普通全局变量和全局对象？ <a class="header-anchor" href="#_6️⃣-总结-为什么js同时拥有普通全局变量和全局对象" aria-hidden="true">#</a></h2><p>全局对象通常被认为是一种错误。基于此，新的构建，比如 <code>const | let | classes</code> 创建普通全局变量（在脚本作用域时）。</p><p>幸运的是，大多数现代JS都写在 <a href="https://exploringjs.com/impatient-js/ch_modules.html" target="_blank" rel="noreferrer">ESM 和 CJS 模块中</a>。每个模块都拥有自己独立的作用域，这也是为什么统治全局变量的规则在基于模块的代码中，就显得不那么重要了。</p><p id="7"></p><h2 id="_7️⃣-进一步阅读和本章来源" tabindex="-1">7️⃣ 进一步阅读和本章来源 <a class="header-anchor" href="#_7️⃣-进一步阅读和本章来源" aria-hidden="true">#</a></h2><p>ECMAScript规范中的环境和全局对象：</p><ul><li><a href="https://tc39.es/ecma262/#sec-lexical-environments" target="_blank" rel="noreferrer">Section &quot;Lexical Environments&quot;</a> 提供对环境的概览</li><li><a href="https://tc39.es/ecma262/#sec-global-environment-records" target="_blank" rel="noreferrer">Section &quot;Global Environment Records&quot;</a> 介绍了全局环境</li><li><a href="https://tc39.es/ecma262/#sec-ecmascript-standard-built-in-objects" target="_blank" rel="noreferrer">Section &quot;ECMAScript Standard Built-in Objects&quot;</a> 描述ECMAScript如何管理其内置对象的（包括全局对象）</li></ul><p><code>globalThis</code>:</p><ul><li><a href="https://2ality.com/2019/08/global-this.html" target="_blank" rel="noreferrer">ES feature: globalThis</a> 2ality文章</li><li><a href="https://mathiasbynens.be/notes/globalthis" target="_blank" rel="noreferrer">Ahorrifying globalThis polyfill in universal JavaScript</a> 各种访问全局 <code>this</code> 的方式</li></ul><p>浏览器中的全局对象：</p><ul><li><a href="https://blog.whatwg.org/windowproxy-window-and-location" target="_blank" rel="noreferrer">Defining the WindowProxy, Window and Location objects</a> 浏览器发生了什么</li><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#realms-settings-objects-global-objects" target="_blank" rel="noreferrer">section &quot;Realm, settings objects and global objects&quot;</a> WHATWG HTML标准（非常技术性）</li><li>在ECMAScript 规范中，我们可以看到浏览器如何自定义全局this的 <a href="https://tc39.es/ecma262/#sec-initializehostdefinedrealm" target="_blank" rel="noreferrer">section &quot;InitializeHostDefinedRealm()&quot;</a></li></ul><p>原文链接：</p><ul><li><a href="https://exploringjs.com/deep-js/ch_global-scope.html" target="_blank" rel="noreferrer">5 A Detailed look at global variables</a></li></ul><p>2022年07月04日16:22:00</p>',76),t=[p];function c(i,r,d,y,h,D){return a(),l("div",null,t)}const C=s(o,[["render",c]]);export{A as __pageData,C as default};
