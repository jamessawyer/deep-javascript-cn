import{_ as s,c as a,o as n,O as l}from"./chunks/framework.103df890.js";const A=JSON.parse('{"title":"属性赋值vs属性定义","description":"","frontmatter":{"title":"属性赋值vs属性定义"},"headers":[],"relativePath":"4/Properties-assignment-vs-definition.md","lastUpdated":1682474873000}'),o={name:"4/Properties-assignment-vs-definition.md"},e=l(`<p>目录：</p><nav class="table-of-contents"><ul><li><a href="#_1️⃣-赋值-vs-定义">1️⃣ 赋值 vs. 定义</a><ul><li><a href="#_1-1-赋值-assignment">1.1 赋值（assignment）</a></li><li><a href="#_1-2-定义-definition">1.2 定义（definition）</a></li></ul></li><li><a href="#_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory">2️⃣ ⭐理论上的赋值和定义(Assignment and definition in theory)</a><ul><li><a href="#_2-1-给一个属性赋值-assigning-to-a-property">2.1 给一个属性赋值（Assigning to a property）</a></li><li><a href="#_2-2-定义一个属性-defining-a-property">2.2 定义一个属性（Defining a property）</a></li></ul></li><li><a href="#_3️⃣-定义和赋值实践-definition-and-assignment-in-practice">3️⃣ 定义和赋值实践（Definition and assignment in practice）</a><ul><li><a href="#_3-1-只有定义允许使用任何特性创建属性">3.1 只有定义允许使用任何特性创建属性</a></li><li><a href="#_3-2-赋值操作符不会改变原型中的属性">3.2 赋值操作符不会改变原型中的属性</a></li><li><a href="#_3-3-⭐赋值会调用setters-而定义不会">3.3 ⭐赋值会调用setters，而定义不会</a></li><li><a href="#_3-4-继承的只读属性阻止通过赋值创建自己的属性">3.4 继承的只读属性阻止通过赋值创建自己的属性</a></li></ul></li><li><a href="#_4️⃣-哪些语言构造使用定义-哪些使用赋值">4️⃣ 哪些语言构造使用定义，哪些使用赋值？</a><ul><li><a href="#_4-1-⭐对象字面量的属性是通过定义添加的">4.1 ⭐对象字面量的属性是通过定义添加的</a></li><li><a href="#_4-2-赋值操作符-总是使用赋值">4.2 赋值操作符 = 总是使用赋值</a></li><li><a href="#_4-3-⭐-公有类字段通过定义的方式添加">4.3 ⭐ 公有类字段通过定义的方式添加</a></li></ul></li><li><a href="#_5️⃣-进一步阅读和本章源码">5️⃣ 进一步阅读和本章源码</a></li><li><a href="#_6️⃣-小结-译者注">6️⃣ 小结（译者注）</a></li></ul></nav><p>📚 有2种方式创建或改变对象 <code>obj</code> 的属性 <code>prop</code>:</p><ul><li><em>赋值</em>： <code>obj.prop = true</code></li><li><em>定义</em>： <code>Object.defineProperty(obj, prop, { value: true })</code></li></ul><p>本章将解释2种方式的工作原理。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>前置知识：属性特性和属性描述器</p></div><p id="1"></p><h2 id="_1️⃣-赋值-vs-定义" tabindex="-1">1️⃣ 赋值 vs. 定义 <a class="header-anchor" href="#_1️⃣-赋值-vs-定义" aria-label="Permalink to &quot;1️⃣ 赋值 vs. 定义&quot;">​</a></h2><p id="1.1"></p><h3 id="_1-1-赋值-assignment" tabindex="-1">1.1 赋值（assignment） <a class="header-anchor" href="#_1-1-赋值-assignment" aria-label="Permalink to &quot;1.1 赋值（assignment）&quot;">​</a></h3><p>我们使用 赋值操作符 <code>=</code> 给对象 <code>obj</code> 上的属性 <code>.prop</code> 赋一个值 <code>value</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value</span></span></code></pre></div><p>👩‍🏫 这个操作符工作效果的差异取决于 <code>.prop</code> 属性是什么：</p><ul><li><strong>改变属性</strong>：如果已经存在一个自身数据属性 <code>.prop</code>，赋值会将其值更改为 <code>value</code></li><li><strong>调用setters</strong>：如果对 <code>.prop</code> 存在一个自身的或者继承的setter（设置器），赋值会调用该setter</li><li><strong>创建属性</strong>： 如果不存在自身或者继承的数据属性 <code>.prop</code> 和 没有自身的或者继承的 <code>setter</code>，赋值会创建一个新的自身数据属性</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>即：赋值的主要目的是做出改变，这也是为什么它支持setters。（记住这句话，后面内容会围绕着这句话深入说明）</p></div><p id="1.2"></p><h3 id="_1-2-定义-definition" tabindex="-1">1.2 定义（definition） <a class="header-anchor" href="#_1-2-定义-definition" aria-label="Permalink to &quot;1.2 定义（definition）&quot;">​</a></h3><p>为了给 <code>obj</code> 定义一个属性 <code>propKey</code>，我们使用如下面方法的操作：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> propKey</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> propDesc)</span></span></code></pre></div><p>👩‍🏫 这个方法的工作效果取决于属性看起来是什么：</p><ul><li><strong>改变属性</strong>：如果自身存在 <code>propKey</code>，定义根据属性描述器 <code>propDesc</code> 改变其属性特性</li><li><strong>创建属性</strong>： 如果不存在键为 <code>propKey</code> 的属性，定义会使用指定的 <code>propDesc</code> 创建一个自身属性，并包含特性。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>即：定义的主要目的是创建一个自身属性（<strong>即使存在继承的setter，它也会忽略它</strong> 💡），并且改变属性特性。（记住这句话，后面内容会围绕着这句话深入说明）</p></div><p id="2"></p><h2 id="_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory" tabindex="-1">2️⃣ ⭐理论上的赋值和定义(Assignment and definition in theory) <a class="header-anchor" href="#_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory" aria-label="Permalink to &quot;2️⃣ ⭐理论上的赋值和定义(Assignment and definition in theory)&quot;">​</a></h2><p>👩🏻‍🏫 在ECMAScript规范中的属性描述器：</p><p>在规范操作中，属性描述器不是JS对象，而是 <a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type" target="_blank" rel="noreferrer">Records</a>，Records是规范内部数据结构，它拥有 <code>fields</code>。<em>字段的键使用双中括号。</em> 比如， <strong><code>Desc.[[Configurable]]</code></strong> 会访问字段 <code>Desc</code> 的 <code>.[[Configurable]]</code>。Records与外部世界交互时，会转换成JS对象，或者从JS对象转换为Records。</p><p id="2.1"></p><h3 id="_2-1-给一个属性赋值-assigning-to-a-property" tabindex="-1">2.1 给一个属性赋值（Assigning to a property） <a class="header-anchor" href="#_2-1-给一个属性赋值-assigning-to-a-property" aria-label="Permalink to &quot;2.1 给一个属性赋值（Assigning to a property）&quot;">​</a></h3><p>给一个属性赋值的操作实际是通过ECMAScript规范中的 <a href="https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor" target="_blank" rel="noreferrer">下面操作</a> 实现的：📒</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">OrdinarySetWithOwnDescriptor</span><span style="color:#A6ACCD;">(O</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> P</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> V</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Receiver</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ownDesc): boolean</span></span></code></pre></div><p>参数含义：</p><ul><li><code>O</code> 表示当前访问的对象</li><li><code>P</code> 表示我们正在赋值的属性的键</li><li><code>V</code> 表示我们正在赋的值</li><li><code>Receiver</code> 表示赋值开始的对象</li><li><code>ownDesc</code> 是 <code>O[P]</code> 的描述器，或者属性不存在时为 <code>null</code></li></ul><p>返回值表示操作是否成功。<strong>严格模式</strong> 下，如果 <code>OrdinarySetWithOwnDescriptor()</code> 失败时，会抛出 <code>TypeError</code>。</p><p>👩🏻‍🏫 下面是这个算法的大致总结：</p><ul><li>该算法会遍历 <code>Receiver</code> 的原型链，直到它找到键为 <code>P</code> 的属性。遍历通过递归调用 <code>OrdinarySetWithOwnDescriptor()</code> 完成。在递归的过程中，<code>O</code> 会发生变化，指向当前访问的对象，而 <code>Receiver</code> 是始终保持不变的。😎</li><li>取决于遍历找到了什么，会在（遍历开始的地方） <code>Receiver</code> 上创建自身属性或者发生其它的事情</li></ul><p>这个算法更详细的过程如下：</p><ul><li><p>如果 <code>ownDesc</code> 是 <code>undefined</code>，则表示我们没有发现键为 <code>P</code> 的属性：</p><ul><li><p><code>If</code>: <code>O</code> 有一个原型 <code>parent</code>，则返回 <code>parent.[[Set]](P, V, Receiver)</code> 。这会延续我们的搜索。方法的调用通常以递归调用 <code>OrdinarySetWithOwndescriptor()</code> 结束</p></li><li><p><code>Else</code>:（即 <code>O</code> 没有原型）我们对 <code>P</code> 属性的搜索失败，然后我们按如下方式设置 <code>ownDesc</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Value</span><span style="color:#F07178;">]]: </span><span style="color:#89DDFF;">undefined,</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Writable</span><span style="color:#F07178;">]]: </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Enumerable</span><span style="color:#F07178;">]]: </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Configurable</span><span style="color:#F07178;">]]: </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>使用这个 <code>ownDesc</code>，下一个 <code>if</code> 语句会在 <code>Receiver</code> 上创建一个自身属性</p></li></ul></li><li><p>如果 <code>ownDesc</code> 指定了一个<strong>数据属性（<code>data property</code>）</strong>，则表示我们发现一个属性：</p><ul><li>如果 <code>ownDesc.[[Writable]]</code> 是 <code>false</code>，返回 <code>false</code>。<strong>这意味着，任何不可写属性 <code>P</code>(自身或继承的)都会阻止赋值操作</strong> 💡</li><li>让 <code>let exstingDescriptor = Receiver.[[GetOwnProperty]](p)</code>。即在赋值开始的地方取回属性描述器。我们现在就有了如下一些东西： <ul><li>当前对象 <code>O</code> 和 当前属性描述器 <code>ownDesc</code> 在一个手上</li><li>原始对象 <code>Receiver</code> 和原始属性描述器 <code>existingDescriptor</code> 在另一个手上</li></ul></li><li>如果 <code>existingDescriptor</code> 不是 <code>undefined</code>: <ul><li>(如果我们到达这里了，表示我们仍在原型链的开始地方 - 我们只有在 <code>Receiver</code> 上不存在属性 <code>P</code> 时才开始递归)</li><li>下面2个 <code>if</code> 条件应当永远不为 <code>true</code>，因为 <code>ownDesc</code> 和 <code>existingDescriptor</code> 应当是相等的： <ul><li>如果 <code>existingDescriptor</code> 指定一个访问器，返回 <code>false</code></li><li>如果 <code>existingDescriptor.[[Writable]] </code> 为 <code>false</code>，返回 <code>false</code></li></ul></li><li>返回 <code>Receiver.[[DefineOwnProperty]](P, { [[Value]]: V })</code>。<strong>这个内部方法执行定义，用于我们改变属性 <code>Receiver[P]</code> 的值</strong>。定义算法会在下面子节中描述</li></ul></li><li>Else：（如果 <code>existingDescriptor</code> 为 <code>undefined</code>） <ul><li>（如果我们达到这里，则表示 <code>Receiver</code> 不存在键为 <code>P</code> 的自身属性）</li><li>返回 <code>CreateDataProperty(Receiver, P, V)</code> (<a href="https://tc39.es/ecma262/#sec-createdataproperty" target="_blank" rel="noreferrer">这个操作</a> 会对其第一个参数创建自身属性)</li></ul></li></ul></li><li><p>（如果我们到这里，则表示 <code>ownDesc</code> 描述一个自身的或者继承的 <strong>访问器属性（<code>accessor property</code>）</strong>）</p></li><li><p><code>let setter = ownDesc.[[Set]]</code></p></li><li><p><code>if(setter == undefined) return false</code></p></li><li><p>执行 <code>Call(setter, Receiver, «v»)</code>。<a href="https://tc39.es/ecma262/#sec-call" target="_blank" rel="noreferrer">Call()</a> 会调用函数对象 <code>setter</code>，并将 <code>this</code> 设置为 <code>Receiver</code>，单一参数为 <code>v</code>(法语括号 «» 用于规范中的列表)</p></li><li><p>返回 <code>true</code></p></li></ul><blockquote><p>我们如何从一个赋值到 OrdinarySetWithOwnDescriptor() 的？</p></blockquote><p>不使用解构计算赋值会涉及如下步骤：</p><ol><li>在规范中，计算位于 <a href="https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation" target="_blank" rel="noreferrer">AssignmentExpression 运行时语义这一节中</a>。这一节处理为匿名函数、解构等提供名称的问题</li><li>如果没有解构模式，则会使用 <a href="https://tc39.es/ecma262/#sec-putvalue" target="_blank" rel="noreferrer">PutValue()</a> 完成赋值</li><li>对于属性赋值，<code>PutValue()</code> 调用内部方法 <code>.[[Set]]()</code></li><li>对普通对象，<a href="https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" target="_blank" rel="noreferrer">.[[Set]]()</a> 会调用 <code>OrdinarySet()</code> (它又会调用 <code>OrdinarySetWithOwnDescriptor()</code>)，然后返回结果😂</li></ol><p>🚨 注意的是，在严格模式下，如果 <code>.[[Set]]()</code> 的结果为false， <code>PutValue()</code> 会抛出 <code>TypeError</code></p><p id="2.2"></p><h3 id="_2-2-定义一个属性-defining-a-property" tabindex="-1">2.2 定义一个属性（Defining a property） <a class="header-anchor" href="#_2-2-定义一个属性-defining-a-property" aria-label="Permalink to &quot;2.2 定义一个属性（Defining a property）&quot;">​</a></h3><p>定义一个属性的操作实际是通过ECMAScript规范中的 <a href="https://tc39.es/ecma262/#sec-validateandapplypropertydescriptor" target="_blank" rel="noreferrer">下面操作</a> 实现的：📒</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">ValidateAndApplyPropertyDescriptor</span><span style="color:#A6ACCD;">(O</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> P</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> extensible</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Desc</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> current): boolean</span></span></code></pre></div><p>参数含义：</p><ul><li><code>O</code> 表示我们想定义属性的对象。当 <code>O</code> 为 <code>undefined</code> 时，会使用一种特殊的仅验证模式。我们在这里忽略了这种模式。</li><li><code>P</code> 我们想定义的属性key</li><li><code>extensible</code> 指示对象 <code>O</code> 是否可扩展</li><li><code>Desc</code> 是属性描述器，用于指定属性的特性</li><li><code>current</code> 如果自身属性 <code>O[P]</code> 存在的话，它包含属性描述器，否则 <code>current</code> 为 <code>undefined</code></li></ul><p>操作的结果是一个布尔值，表示操作是否成功。失败可能导致不同的后果。一些调用者会忽略这些结果，而有些调用者，比如 <code>Object.defineProperty()</code> ，在结果为 <code>false</code> 时抛出 <code>TypeError</code>。</p><p>下面是这个算法的总结：</p><ul><li>如果 <code>current</code> 是 <code>undefined</code>， 表示属性 <code>P</code> 目前还不存在，必须被创建 <ul><li>如果 <code>extensible</code> 为 <code>false</code>（即对象不可扩展），返回 <code>false</code>，表示属性不能被添加</li><li>否则，检查 <code>Desc</code>，并且创建一个数据属性或者访问器属性</li><li>返回 <code>true</code></li></ul></li><li>如果 <code>Desc</code> 不存在任何字段，返回 <code>true</code>，表示这个操作成功了（因为不需要做任何改变）</li><li>如果 <code>current.[[Configurable]]</code> 是 <code>false</code>（译者注：即对象不可配置）： <ul><li>（<code>Desc</code> 不允许改变除 <code>value</code> 之外的任何特性）</li><li>如果 <code>Desc.[[Configurable]]</code> 存在，它必须和 <code>current.[[Configurable]]</code> 是一样的值，如果不是，则返回 <code>false</code></li><li>对 <code>Desc.[[Enumerable]]</code> 执行相同的检测</li></ul></li><li>接下来：我们 <em>验证</em> 属性描述器 <code>Desc</code>, <code>current</code> 所描述的特性值是否可更改为 <code>Desc</code> 指定的值？如果不能，则返回 <code>false</code>;如果可以，则继续： <ul><li><code>If</code> 描述器是 <em>通用的</em>（即没有指定为数据属性还是访问器属性，译者注：即只指定了 <code>configurable | enumerable</code>），则验证通过，我们继续</li><li><code>Else if</code> 一个描述器指定了数据属性，而另一个指定为了访问器属性： <ul><li>当前属性必须是可以配置的（否者它的特性无法根据需要进行更改）。如果不可配置，则返回 <code>false</code></li><li>将当前属性从数据属性更改为访问器属性，反之亦然。当这样做时，<code>.[[Configurable]]</code> 和 <code>.[[Enumerable]]</code> 的值会保存下来，其它特性得到 <a href="https://exploringjs.com/deep-js/ch_property-attributes-intro.html#property-attributes" target="_blank" rel="noreferrer">默认值</a>（对象值特性为 <code>undefined</code>，布尔值特性为 <code>false</code>）</li></ul></li><li><code>Else if</code> 2个描述器都为数据属性： <ul><li>如果 <code>current.[[Configurable]]</code> 和 <code>current.[[Writable]]</code> 都是 <code>false</code>，则不允许任何改变发生，<code>Desc</code> 和 <code>current</code> 必须指定相同的特性： <ul><li>（因为 <code>current.[[Configurable]]</code> 为 <code>false</code>, <code>Desc.[[Configurable]]</code> 和 <code>Desc.[[Enumerable]]</code> 在先前已经被检验，并且已经为正确值）</li><li>如果 <code>Desc.[[Writable]]</code> 存在，并且是 <code>true</code>，则返回 <code>true</code></li><li>如果 <code>Desc.[[Value]]</code> 存在，并且和 <code>current.[[Value]]</code> 值不相同，则返回 <code>false</code></li><li>没有其他要做的了，返回 <code>true</code> 表示算法成功</li><li>(<em>正常情况下，对不可配置属性，我们只能改变其value，而不能更改其它特性，但是存在一个例外规则，我们可以将可写特性更改为不可写。这个算法会正确的处理这个例外情况</em>)😅</li></ul></li></ul></li><li><code>Else</code> （2个描述器都是访问器属性：） <ul><li>如果 <code>current.[[Configurable]]</code> 是 <code>false</code>，则不允许任何改变。并且 <code>Desc</code> 和 <code>current</code> 必须指定相同特性： <ul><li>（由于 <code>current.[[Configurable]]</code> 已经为 <code>false</code>，<code>Desc.[[Configurable]]</code> 和 <code>Desc.[[Enumerable]]</code> 在之前已经校验，并且拥有正确的值）</li><li>如果 <code>Desc.[[Set]]</code> 存在，它必须和 <code>current.[[Set]]</code> 的值一样，否则返回 <code>false</code></li><li><code>Desc.[[Get]]</code> 执行相同的校验</li><li>没有更多要做的了。返回 <code>true</code> 表示算法成功。</li></ul></li></ul></li></ul></li><li>设置属性 <code>P</code> 的特性为 <code>Desc</code> 指定的值。通过验证，我们能确保所有的改变是允许的</li><li>返回 <code>true</code></li></ul><p id="3"></p><h2 id="_3️⃣-定义和赋值实践-definition-and-assignment-in-practice" tabindex="-1">3️⃣ 定义和赋值实践（Definition and assignment in practice） <a class="header-anchor" href="#_3️⃣-定义和赋值实践-definition-and-assignment-in-practice" aria-label="Permalink to &quot;3️⃣ 定义和赋值实践（Definition and assignment in practice）&quot;">​</a></h2><p>本节描述属性定义和赋值工作的一些结果。</p><p id="3.1"></p><h3 id="_3-1-只有定义允许使用任何特性创建属性" tabindex="-1">3.1 只有定义允许使用任何特性创建属性 <a class="header-anchor" href="#_3-1-只有定义允许使用任何特性创建属性" aria-label="Permalink to &quot;3.1 只有定义允许使用任何特性创建属性&quot;">​</a></h3><p>如果我们通过<strong>赋值</strong>的方式创建一个自身属性，它总是将 <code>writable</code> &amp; <code>enumerable</code> &amp; <code>configurable</code> 特性设置为 <code>true</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">dataProp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">deepEqual</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getOwnPropertyDescriptor</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">dataProp</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">writable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">enumerable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">configurable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div><p><strong>因此，如果我们想要指定任意特性，我们必须使用 定义 的方式</strong>。</p><p>并且，我们可以在对象字面量中创建 <code>getters</code> &amp; <code>setters</code>，但是我们不能之后通过赋值的方式添加访问器属性，<strong>是的，我们需要使用定义😏</strong>。</p><p id="3.2"></p><h3 id="_3-2-赋值操作符不会改变原型中的属性" tabindex="-1">3.2 赋值操作符不会改变原型中的属性 <a class="header-anchor" href="#_3-2-赋值操作符不会改变原型中的属性" aria-label="Permalink to &quot;3.2 赋值操作符不会改变原型中的属性&quot;">​</a></h3><p>让我们看看下面示例，<code>obj</code> 从 <code>proto</code> 继承了 <code>prop</code> 属性:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(prop)</span></span></code></pre></div><p>我们不能通过给 <code>obj.prop</code> 赋值的方式（破坏性的）改变 <code>proto.prop</code>。这样做只会创建一个新的自身属性：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">deepEqual</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#A6ACCD;">(obj)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  []</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 赋值</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 赋值生效</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 但是我们创建的是自身的属性，尝试覆盖 proto.prop</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 并没有改变原型上的属性</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">deepEqual</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#A6ACCD;">(obj)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(proto</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>这种行为的理由如下：</p><p>原型拥有自己的属性，它的值被所有后代共享。如果我们只想改变它的一个后代中的该属性，我们必须非破坏性的，通过覆盖的形式完成，这样就不会影响到其它后代。</p><p id="3.3"></p><h3 id="_3-3-⭐赋值会调用setters-而定义不会" tabindex="-1">3.3 ⭐赋值会调用setters，而定义不会 <a class="header-anchor" href="#_3-3-⭐赋值会调用setters-而定义不会" aria-label="Permalink to &quot;3.3 ⭐赋值会调用setters，而定义不会&quot;">​</a></h3><p>定义 <code>obj</code> 的属性 <code>prop</code> 和给它赋值有什么区别呢？</p><p>👩🏻‍🏫 如果我们使用<strong>定义</strong>，则我们的意图要么是为了创建一个自身的（非继承的）属性，要么是为了改变一个自身的属性。因此，<strong>下例中定义会忽略 <code>.prop</code> 继承的setter</strong>:</p><p>🌰</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> setterWasCalled </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoGetter</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 🚨 注意这里并没有进行赋值操作 this.prop = x</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">setterWasCalled</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// obj 的原型是 proto</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 原型上的属性</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">propGetter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 定义 obj.prop 添加到对象自身</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  obj</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objData</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 💡 可以看出 原型中的 setter并没有被触发</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(setterWasCalled</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 创建了的自身属性，掩盖了原型上的同名属性</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objData</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>而，如果我们使用 <strong>赋值</strong>，则我们的意图一般是改变<strong>已经存在的东西</strong>，并且 <strong>该改变会通过 setter 处理</strong> 🤔</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> setterWasCalled </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoGetter</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 🚨 注意这里并没有进行赋值操作 this.prop = x</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">setterWasCalled</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// obj 的原型是 proto</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">propGetter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 给 obj.prop 赋值</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objData</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 📚 赋值会触发原型上的 setter</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(setterWasCalled</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 📚 getter仍是激活的</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 因为上面的 setter 中并没有进行赋值</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 所以这里的 obj.prop 仍旧是 &#39;propGetter&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoGetter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p id="3.3"></p><h3 id="_3-4-继承的只读属性阻止通过赋值创建自己的属性" tabindex="-1">3.4 继承的只读属性阻止通过赋值创建自己的属性 <a class="header-anchor" href="#_3-4-继承的只读属性阻止通过赋值创建自己的属性" aria-label="Permalink to &quot;3.4 继承的只读属性阻止通过赋值创建自己的属性&quot;">​</a></h3><p>假如原型的属性 <code>.prop</code> 是只读的，会发生什么呢？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">writable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>👩🏻‍🏫 <strong>任何从 <code>proto</code> 继承只读属性 <code>.prop</code> 的对象，都不能通过赋值的方式创建自身同名属性</strong></p><p>🌰：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line highlighted"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">throw</span><span style="color:#A6ACCD;">(</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 尝试在对象上使用赋值的方式 创建同名属性</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;font-style:italic;">^</span><span style="color:#C3E88D;">TypeError: Cannot assign to read only property &#39;prop&#39;</span><span style="color:#89DDFF;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>为什么我们不能赋值呢？理由是，通过创建自身属性的方式覆盖继承的属性，被视作是 <a href="https://exploringjs.com/deep-js/ch_updating-destructively-and-nondestructively.html" target="_blank" rel="noreferrer">非破坏性改变</a> 继承的属性。<strong>按理说，如果一个属性是不可写的，我们不能去覆盖它</strong>。</p><p>🤣 然而，<strong>定义</strong> <code>.prop</code> 仍可正常工作，让我们覆盖它：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  obj</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p><em>没有 <code>setter</code> 的访问器属性，也可被认作是只读属性</em>：💡</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoValue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">throw</span><span style="color:#A6ACCD;">(</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 尝试在对象上使用赋值的方式 创建同名属性</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;font-style:italic;">^</span><span style="color:#C3E88D;">Uncaught TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter&#39;</span><span style="color:#89DDFF;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>💡 <em>override mistake</em>: 优点和缺点</p><p>事实上，原型链上只读属性阻止赋值，之前称之为 <em>override mistake</em>:</p><ul><li><p>它在ECMAScript5.1 中被引入</p></li><li><p>一方面，这种行为和原型链继承以及setters工作原理保持一致性（所以，这并不是一个错误😅）</p></li><li><p>另一方面，这种行为，在深度冻结全局对象时，会引发不想要的副作用</p></li><li><p>曾尝试改变这种行为，但会破坏Lodash这个库，因此被放弃了 <a href="https://github.com/tc39/ecma262/pull/1320#issuecomment-443485524" target="_blank" rel="noreferrer">PR On GitHub</a></p></li><li><p>背景知识</p><ul><li><a href="https://github.com/tc39/ecma262/pull/1307" target="_blank" rel="noreferrer">PR On GitHub</a></li><li><a href="http://wiki.ecmascript.org/doku.php?id=strawman:fixing_override_mistake" target="_blank" rel="noreferrer">Wiki page onn ECMAScript</a></li></ul></li></ul><p id="4"></p><h2 id="_4️⃣-哪些语言构造使用定义-哪些使用赋值" tabindex="-1">4️⃣ 哪些语言构造使用定义，哪些使用赋值？ <a class="header-anchor" href="#_4️⃣-哪些语言构造使用定义-哪些使用赋值" aria-label="Permalink to &quot;4️⃣ 哪些语言构造使用定义，哪些使用赋值？&quot;">​</a></h2><p>这一节，我们看看语言构造中哪些是使用定义，哪些又是使用赋值的。<strong>我们通过跟踪是否调用了继承的setter来检测使用了哪个操作。</strong> 可以查看上面 <code>3.3</code> 这一小节。</p><p id="4.1"></p><h3 id="_4-1-⭐对象字面量的属性是通过定义添加的" tabindex="-1">4.1 ⭐对象字面量的属性是通过定义添加的 <a class="header-anchor" href="#_4-1-⭐对象字面量的属性是通过定义添加的" aria-label="Permalink to &quot;4.1 ⭐对象字面量的属性是通过定义添加的&quot;">​</a></h3><p>👩🏻‍🏫 当我们创建属性通过一个对象字面量，JS总是使用定义（因此，永远不会调用继承的setters）：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">__proto__</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> proto</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 字面量的方式添加原型</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 通过 \`定义\` 的方式添加</span></span>
<span class="line highlighted"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 并不会触发原型上的 setter</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p id="4.2"></p><h3 id="_4-2-赋值操作符-总是使用赋值" tabindex="-1">4.2 赋值操作符 = 总是使用赋值 <a class="header-anchor" href="#_4-2-赋值操作符-总是使用赋值" aria-label="Permalink to &quot;4.2 赋值操作符 = 总是使用赋值&quot;">​</a></h3><p>赋值操作符 <code>=</code> 总是使用赋值方式创建或者改变属性</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto) </span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 正常赋值</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 💡 可以看出会赋值调用原型setter</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 通过解构方式赋值：</span></span>
<span class="line"><span style="color:#A6ACCD;">[obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop] </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">def</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">def</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p id="4.3"></p><h3 id="_4-3-⭐-公有类字段通过定义的方式添加" tabindex="-1">4.3 ⭐ 公有类字段通过定义的方式添加 <a class="header-anchor" href="#_4-3-⭐-公有类字段通过定义的方式添加" aria-label="Permalink to &quot;4.3 ⭐ 公有类字段通过定义的方式添加&quot;">​</a></h3><p>👩🏻‍🏫 即使类中公有字段和赋值语法一样，但是 <strong>它们没有使用赋值的方式创建属性，而是使用定义的方式</strong>（类似对象字面量中的属性）</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument1</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop1</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">A prop1 set</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">A prop2 set</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 和父类设置器中同名属性</span></span>
<span class="line highlighted"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">prop1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">one</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">()</span></span>
<span class="line highlighted"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">prop2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">two</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">B</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 📚 公有字段使用 \`定义\`</span></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 因此不会触发原型上的同名setter</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">undefined</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#676E95;font-style:italic;">// 在构造器中，触发 \`赋值\`</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">two</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p id="5"></p><h2 id="_5️⃣-进一步阅读和本章源码" tabindex="-1">5️⃣ 进一步阅读和本章源码 <a class="header-anchor" href="#_5️⃣-进一步阅读和本章源码" aria-label="Permalink to &quot;5️⃣ 进一步阅读和本章源码&quot;">​</a></h2><ul><li><a href="https://exploringjs.com/impatient-js/ch_proto-chains-classes.html#prototype-chains" target="_blank" rel="noreferrer">Property chains - JS for impatient programmers</a></li><li><a href="https://mail.mozilla.org/pipermail/es-discuss/2012-July/024227.html" target="_blank" rel="noreferrer">es-discuss mailing list</a> 当ES只拥有数据属性，并且ES代码无法操作属性特性时，赋值和定义之间的区别就不是很重要了</li></ul><h2 id="_6️⃣-小结-译者注" tabindex="-1">6️⃣ 小结（译者注） <a class="header-anchor" href="#_6️⃣-小结-译者注" aria-label="Permalink to &quot;6️⃣ 小结（译者注）&quot;">​</a></h2><ol><li>赋值的主要目的是什么？ 做出改变，支持setters（和继承密切相关）</li><li>定义的主要目的是什么？ 创建一个自身的属性，忽略继承的setters</li><li>理论上，赋值和定义在ECMAScript规范中的算法实现过程</li><li>定义可以添加任何属性特性</li><li>赋值不会改变原型链上的同名属性</li><li>赋值会调用原型上的同名 setter，而定义不会（🚀）</li><li>继承只读属性，赋值和父类同名的属性，会抛出错误；而定义不会</li><li>对象字面量属性是通过定义形式创建的（🚀）</li><li><code>=</code> 操作符总是执行赋值操作</li><li>类的公有字段通过定义创建；而类构造器中的属性通过赋值创建（🚀）</li></ol><p>2022年07月19日23:36:28</p>`,111),p=[e];function t(c,r,i,D,y,F){return n(),a("div",null,p)}const d=s(o,[["render",t]]);export{A as __pageData,d as default};
