<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>属性赋值vs属性定义 | Deep JavaScript</title>
    <meta name="description" content="A book in the depths of JavaScript">
    <link rel="stylesheet" href="/deep-javascript-cn/assets/style.49790c05.css">
    <link rel="modulepreload" href="/deep-javascript-cn/assets/app.1f1ae7ae.js">
    <link rel="modulepreload" href="/deep-javascript-cn/assets/4_Properties-assignment-vs-definition.md.ad93b466.lean.js">
    
    <link rel="icon" href="/deep-javascript-cn/favicon.ico">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-6b5fd0a9><!--[--><!--]--><!--[--><span tabindex="-1" data-v-45f6ae50></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-45f6ae50> Skip to content </a><!--]--><!----><header class="VPNav" data-v-6b5fd0a9 data-v-0e356168><div class="VPNavBar has-sidebar" data-v-0e356168 data-v-8856f192><div class="container" data-v-8856f192><div class="VPNavBarTitle has-sidebar" data-v-8856f192 data-v-6a6f7ff6><a class="title" href="/deep-javascript-cn/" data-v-6a6f7ff6><!--[--><img class="VPImage logo" src="/deep-javascript-cn/js.svg" data-v-73ae1788><!--]--><!--[-->Deep JavaScript<!--]--></a></div><div class="content" data-v-8856f192><!----><!----><!----><div class="VPNavBarAppearance appearance" data-v-8856f192 data-v-311055f2><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-311055f2 data-v-781f9d1b data-v-1dda4c9c><span class="check" data-v-1dda4c9c><span class="icon" data-v-1dda4c9c><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-781f9d1b><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-781f9d1b><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-8856f192 data-v-0562f5c0 data-v-8dccea88><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-8dccea88><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-8dccea88><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-8dccea88><div class="VPMenu" data-v-8dccea88 data-v-e73581a2><!----><!--[--><!--[--><!----><div class="group" data-v-0562f5c0><div class="item appearance" data-v-0562f5c0><p class="label" data-v-0562f5c0>Appearance</p><div class="appearance-action" data-v-0562f5c0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-0562f5c0 data-v-781f9d1b data-v-1dda4c9c><span class="check" data-v-1dda4c9c><span class="icon" data-v-1dda4c9c><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-781f9d1b><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-781f9d1b><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8856f192 data-v-6f008456><span class="container" data-v-6f008456><span class="top" data-v-6f008456></span><span class="middle" data-v-6f008456></span><span class="bottom" data-v-6f008456></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-6b5fd0a9 data-v-92b0f14a><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-92b0f14a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-92b0f14a><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-92b0f14a>Menu</span></button><a class="top-link" href="#" data-v-92b0f14a> Return to top </a></div><aside class="VPSidebar" data-v-6b5fd0a9 data-v-55e4c7db><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-55e4c7db><span class="visually-hidden" id="sidebar-aria-label" data-v-55e4c7db> Sidebar Navigation </span><!--[--><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>Ⅱ.类型，值，和变量</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/deep-javascript-cn/2/Type-coercion-in-JavaScript.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>2.⚡JS中的类型强转</span><!--]--><!----></a><a class="VPLink link" href="/deep-javascript-cn/2/The-destructuring-algorithm.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>3.解构算法</span><!--]--><!----></a><a class="VPLink link" href="/deep-javascript-cn/2/Environments-under-the-hood-of-variables.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>4.⚡环境-变量背后的原理</span><!--]--><!----></a><a class="VPLink link" href="/deep-javascript-cn/2/A-detailed-look-at-global-variables.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>5.⚡深入理解全局变量</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>Ⅲ.数据处理</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>Ⅳ.OOP：对象属性特性</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/deep-javascript-cn/4/Property-attributes-an-Introduction.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>10.⚡属性特性介绍</span><!--]--><!----></a><a class="VPLink link" href="/deep-javascript-cn/4/Protecting-objects-from-changed.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>11.保护对象更改</span><!--]--><!----></a><a class="VPLink link active" href="/deep-javascript-cn/4/Properties-assignment-vs-definition.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>12.⚡属性赋值和属性定义</span><!--]--><!----></a><a class="VPLink link" href="/deep-javascript-cn/4/Enumerability-of-Properties.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>13.属性的可枚举性</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>Ⅴ.OOP技术</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/deep-javascript-cn/5/Techniques-for-instantiating-classes.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>14.⚡实例化类技术（异步属性）</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>Ⅵ.正则表达式</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><!--]--></div></section></div><div class="group" data-v-55e4c7db><section class="VPSidebarGroup collapsible" data-v-55e4c7db data-v-1f69a7ed><div class="title" role="button" data-v-1f69a7ed><h2 class="title-text" data-v-1f69a7ed>Ⅶ.其它话题：元编程</h2><div class="action" data-v-1f69a7ed><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-1f69a7ed><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-1f69a7ed><!--[--><a class="VPLink link" href="/deep-javascript-cn/7/Metaprogramming-with-Proxies.html" data-v-1f69a7ed data-v-f53f775e data-v-5704c677><!--[--><span class="link-text" data-v-f53f775e>20.⚡使用Proxies进行元编程</span><!--]--><!----></a><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-6b5fd0a9 data-v-a4c57a06><div class="VPDoc has-sidebar" data-v-a4c57a06 data-v-79ca2460><div class="container" data-v-79ca2460><div class="aside" data-v-79ca2460><div class="aside-curtain" data-v-79ca2460></div><div class="aside-container" data-v-79ca2460><div class="aside-content" data-v-79ca2460><div class="VPDocAside" data-v-79ca2460 data-v-779d834d><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-779d834d data-v-51e5a8ce><div class="content" data-v-51e5a8ce><div class="outline-marker" data-v-51e5a8ce></div><div class="outline-title" data-v-51e5a8ce>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-51e5a8ce><span class="visually-hidden" id="doc-outline-aria-label" data-v-51e5a8ce> Table of Contents for current page </span><ul class="root" data-v-51e5a8ce><!--[--><li style="" data-v-51e5a8ce><a class="outline-link" href="#_1️⃣-赋值-vs-定义" data-v-51e5a8ce>1️⃣ 赋值 vs. 定义</a><!----></li><li style="" data-v-51e5a8ce><a class="outline-link" href="#_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory" data-v-51e5a8ce>2️⃣ ⭐理论上的赋值和定义(Assignment and definition in theory)</a><!----></li><li style="" data-v-51e5a8ce><a class="outline-link" href="#_3️⃣-定义和赋值实践（definition-and-assignment-in-practice）" data-v-51e5a8ce>3️⃣ 定义和赋值实践（Definition and assignment in practice）</a><!----></li><li style="" data-v-51e5a8ce><a class="outline-link" href="#_4️⃣-哪些语言构造使用定义，哪些使用赋值？" data-v-51e5a8ce>4️⃣ 哪些语言构造使用定义，哪些使用赋值？</a><!----></li><li style="" data-v-51e5a8ce><a class="outline-link" href="#_5️⃣-进一步阅读和本章源码" data-v-51e5a8ce>5️⃣ 进一步阅读和本章源码</a><!----></li><li style="" data-v-51e5a8ce><a class="outline-link" href="#_6️⃣-小结（译者注）" data-v-51e5a8ce>6️⃣ 小结（译者注）</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-779d834d></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-79ca2460><div class="content-container" data-v-79ca2460><!--[--><!--]--><main class="main" data-v-79ca2460><div style="position:relative;" class="vp-doc _deep-javascript-cn_4_Properties-assignment-vs-definition" data-v-79ca2460><div><p>目录：</p><nav class="table-of-contents"><ul><li><a href="#_1️⃣-赋值-vs-定义">1️⃣ 赋值 vs. 定义</a><ul><li><a href="#_1-1-赋值（assignment）">1.1 赋值（assignment）</a></li><li><a href="#_1-2-定义（definition）">1.2 定义（definition）</a></li></ul></li><li><a href="#_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory">2️⃣ ⭐理论上的赋值和定义(Assignment and definition in theory)</a><ul><li><a href="#_2-1-给一个属性赋值（assigning-to-a-property）">2.1 给一个属性赋值（Assigning to a property）</a></li><li><a href="#_2-2-定义一个属性（defining-a-property）">2.2 定义一个属性（Defining a property）</a></li></ul></li><li><a href="#_3️⃣-定义和赋值实践（definition-and-assignment-in-practice）">3️⃣ 定义和赋值实践（Definition and assignment in practice）</a><ul><li><a href="#_3-1-只有定义允许使用任何特性创建属性">3.1 只有定义允许使用任何特性创建属性</a></li><li><a href="#_3-2-赋值操作符不会改变原型中的属性">3.2 赋值操作符不会改变原型中的属性</a></li><li><a href="#_3-3-⭐赋值会调用setters，而定义不会">3.3 ⭐赋值会调用setters，而定义不会</a></li><li><a href="#_3-4-继承的只读属性阻止通过赋值创建自己的属性">3.4 继承的只读属性阻止通过赋值创建自己的属性</a></li></ul></li><li><a href="#_4️⃣-哪些语言构造使用定义，哪些使用赋值？">4️⃣ 哪些语言构造使用定义，哪些使用赋值？</a><ul><li><a href="#_4-1-⭐对象字面量的属性是通过定义添加的">4.1 ⭐对象字面量的属性是通过定义添加的</a></li><li><a href="#_4-2-赋值操作符-总是使用赋值">4.2 赋值操作符 = 总是使用赋值</a></li><li><a href="#_4-3-⭐-公有类字段通过赋值的方式添加">4.3 ⭐ 公有类字段通过赋值的方式添加</a></li></ul></li><li><a href="#_5️⃣-进一步阅读和本章源码">5️⃣ 进一步阅读和本章源码</a></li><li><a href="#_6️⃣-小结（译者注）">6️⃣ 小结（译者注）</a></li></ul></nav><p>📚 有2种方式创建或改变对象 <code>obj</code> 的属性 <code>prop</code>:</p><ul><li><em>赋值</em>： <code>obj.prop = true</code></li><li><em>定义</em>： <code>Object.defineProperty(obj, prop, { value: true })</code></li></ul><p>本章将解释2种方式的工作原理。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>前置知识：属性特性和属性描述器</p></div><p id="1"></p><h2 id="_1️⃣-赋值-vs-定义" tabindex="-1">1️⃣ 赋值 vs. 定义 <a class="header-anchor" href="#_1️⃣-赋值-vs-定义" aria-hidden="true">#</a></h2><p id="1.1"></p><h3 id="_1-1-赋值（assignment）" tabindex="-1">1.1 赋值（assignment） <a class="header-anchor" href="#_1-1-赋值（assignment）" aria-hidden="true">#</a></h3><p>我们使用 赋值操作符 <code>=</code> 给对象 <code>obj</code> 上的属性 <code>.prop</code> 赋一个值 <code>value</code>:</p><div class="language-js"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value</span></span>
<span class="line"></span></code></pre></div><p>👩‍🏫 这个操作符工作效果的差异取决于 <code>.prop</code> 属性是什么：</p><ul><li><strong>改变属性</strong>：如果已经存在一个自身数据属性 <code>.prop</code>，赋值会将其值更改为 <code>value</code></li><li><strong>调用setters</strong>：如果对 <code>.prop</code> 存在一个自身的或者继承的setter（设置器），赋值会调用该setter</li><li><strong>创建属性</strong>： 如果不存在自身或者继承的数据属性 <code>.prop</code> 和 没有自身的或者继承的 <code>setter</code>，赋值会创建一个新的自身数据属性</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>即：赋值的主要目的是做出改变，这也是为什么它支持setters。（记住这句话，后面内容会围绕着这句话深入说明）</p></div><p id="1.2"></p><h3 id="_1-2-定义（definition）" tabindex="-1">1.2 定义（definition） <a class="header-anchor" href="#_1-2-定义（definition）" aria-hidden="true">#</a></h3><p>为了给 <code>obj</code> 定义一个属性 <code>propKey</code>，我们使用如下面方法的操作：</p><div class="language-js"><span class="copy"></span><pre><code><span class="line"><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> propKey</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> propDesc)</span></span>
<span class="line"></span></code></pre></div><p>👩‍🏫 这个方法的工作效果取决于属性看起来是什么：</p><ul><li><strong>改变属性</strong>：如果自身存在 <code>propKey</code>，定义根据属性描述器 <code>propDesc</code> 改变其属性特性</li><li><strong>创建属性</strong>： 如果不存在键为 <code>propKey</code> 的属性，定义会使用指定的 <code>propDesc</code> 创建一个自身属性，并包含特性。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>即：定义的主要目的是创建一个自身属性（<strong>即使存在继承的setter，它也会忽略它</strong> 💡），并且改变属性特性。（记住这句话，后面内容会围绕着这句话深入说明）</p></div><p id="2"></p><h2 id="_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory" tabindex="-1">2️⃣ ⭐理论上的赋值和定义(Assignment and definition in theory) <a class="header-anchor" href="#_2️⃣-⭐理论上的赋值和定义-assignment-and-definition-in-theory" aria-hidden="true">#</a></h2><p>👩🏻‍🏫 在ECMAScript规范中的属性描述器：</p><p>在规范操作中，属性描述器不是JS对象，而是 <a href="https://tc39.es/ecma262/#sec-list-and-record-specification-type" target="_blank" rel="noopener noreferrer">Records</a>，Records是规范内部数据结构，它拥有 <code>fields</code>。<em>字段的键使用双中括号。</em> 比如， <strong><code>Desc.[[Configurable]]</code></strong> 会访问字段 <code>Desc</code> 的 <code>.[[Configurable]]</code>。Records与外部世界交互时，会转换成JS对象，或者从JS对象转换为Records。</p><p id="2.1"></p><h3 id="_2-1-给一个属性赋值（assigning-to-a-property）" tabindex="-1">2.1 给一个属性赋值（Assigning to a property） <a class="header-anchor" href="#_2-1-给一个属性赋值（assigning-to-a-property）" aria-hidden="true">#</a></h3><p>给一个属性赋值的操作实际是通过ECMAScript规范中的 <a href="https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor" target="_blank" rel="noopener noreferrer">下面操作</a> 实现的：📒</p><div class="language-js"><span class="copy"></span><pre><code><span class="line"><span style="color:#82AAFF;">OrdinarySetWithOwnDescriptor</span><span style="color:#A6ACCD;">(O</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> P</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> V</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Receiver</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ownDesc): boolean</span></span>
<span class="line"></span></code></pre></div><p>参数含义：</p><ul><li><code>O</code> 表示当前访问的对象</li><li><code>P</code> 表示我们正在赋值的属性的键</li><li><code>V</code> 表示我们正在赋的值</li><li><code>Receiver</code> 表示赋值开始的对象</li><li><code>ownDesc</code> 是 <code>O[P]</code> 的描述器，或者属性不存在时为 <code>null</code></li></ul><p>返回值表示操作是否成功。<strong>严格模式</strong> 下，如果 <code>OrdinarySetWithOwnDescriptor()</code> 失败时，会抛出 <code>TypeError</code>。</p><p>👩🏻‍🏫 下面是这个算法的大致总结：</p><ul><li>该算法会遍历 <code>Receiver</code> 的原型链，直到它找到键为 <code>P</code> 的属性。遍历通过递归调用 <code>OrdinarySetWithOwnDescriptor()</code> 完成。在递归的过程中，<code>O</code> 会发生变化，指向当前访问的对象，而 <code>Receiver</code> 是始终保持不变的。😎</li><li>取决于遍历找到了什么，会在（遍历开始的地方） <code>Receiver</code> 上创建自身属性或者发生其它的事情</li></ul><p>这个算法更详细的过程如下：</p><ul><li><p>如果 <code>ownDesc</code> 是 <code>undefined</code>，则表示我们没有发现键为 <code>P</code> 的属性：</p><ul><li><p><code>If</code>: <code>O</code> 有一个原型 <code>parent</code>，则返回 <code>parent.[[Set]](P, V, Receiver)</code> 。这会延续我们的搜索。方法的调用通常以递归调用 <code>OrdinarySetWithOwndescriptor()</code> 结束</p></li><li><p><code>Else</code>:（即 <code>O</code> 没有原型）我们对 <code>P</code> 属性的搜索失败，然后我们按如下方式设置 <code>ownDesc</code>:</p><div class="language-js"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Value</span><span style="color:#F07178;">]]: </span><span style="color:#89DDFF;">undefined,</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Writable</span><span style="color:#F07178;">]]: </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Enumerable</span><span style="color:#F07178;">]]: </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  [[</span><span style="color:#A6ACCD;">Configurable</span><span style="color:#F07178;">]]: </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>使用这个 <code>ownDesc</code>，下一个 <code>if</code> 语句会在 <code>Receiver</code> 上创建一个自身属性</p></li></ul></li><li><p>如果 <code>ownDesc</code> 指定了一个<strong>数据属性（<code>data property</code>）</strong>，则表示我们发现一个属性：</p><ul><li>如果 <code>ownDesc.[[Writable]]</code> 是 <code>false</code>，返回 <code>false</code>。<strong>这意味着，任何不可写属性 <code>P</code>(自身或继承的)都会阻止赋值操作</strong> 💡</li><li>让 <code>let exstingDescriptor = Receiver.[[GetOwnProperty]](p)</code>。即在赋值开始的地方取回属性描述器。我们现在就有了如下一些东西： <ul><li>当前对象 <code>O</code> 和 当前属性描述器 <code>ownDesc</code> 在一个手上</li><li>原始对象 <code>Receiver</code> 和原始属性描述器 <code>existingDescriptor</code> 在另一个手上</li></ul></li><li>如果 <code>existingDescriptor</code> 不是 <code>undefined</code>: <ul><li>(如果我们到达这里了，表示我们仍在原型链的开始地方 - 我们只有在 <code>Receiver</code> 上不存在属性 <code>P</code> 时才开始递归)</li><li>下面2个 <code>if</code> 条件应当永远不为 <code>true</code>，因为 <code>ownDesc</code> 和 <code>existingDescriptor</code> 应当是相等的： <ul><li>如果 <code>existingDescriptor</code> 指定一个访问器，返回 <code>false</code></li><li>如果 <code>existingDescriptor.[[Writable]] </code> 为 <code>false</code>，返回 <code>false</code></li></ul></li><li>返回 <code>Receiver.[[DefineOwnProperty]](P, { [[Value]]: V })</code>。<strong>这个内部方法执行定义，用于我们改变属性 <code>Receiver[P]</code> 的值</strong>。定义算法会在下面子节中描述</li></ul></li><li>Else：（如果 <code>existingDescriptor</code> 为 <code>undefined</code>） <ul><li>（如果我们达到这里，则表示 <code>Receiver</code> 不存在键为 <code>P</code> 的自身属性）</li><li>返回 <code>CreateDataProperty(Receiver, P, V)</code> (<a href="https://tc39.es/ecma262/#sec-createdataproperty" target="_blank" rel="noopener noreferrer">这个操作</a> 会对其第一个参数创建自身属性)</li></ul></li></ul></li><li><p>（如果我们到这里，则表示 <code>ownDesc</code> 描述一个自身的或者继承的 <strong>访问器属性（<code>accessor property</code>）</strong>）</p></li><li><p><code>let setter = ownDesc.[[Set]]</code></p></li><li><p><code>if(setter == undefined) return false</code></p></li><li><p>执行 <code>Call(setter, Receiver, «v»)</code>。<a href="https://tc39.es/ecma262/#sec-call" target="_blank" rel="noopener noreferrer">Call()</a> 会调用函数对象 <code>setter</code>，并将 <code>this</code> 设置为 <code>Receiver</code>，单一参数为 <code>v</code>(法语括号 «» 用于规范中的列表)</p></li><li><p>返回 <code>true</code></p></li></ul><blockquote><p>我们如何从一个赋值到 OrdinarySetWithOwnDescriptor() 的？</p></blockquote><p>不使用解构计算赋值会涉及如下步骤：</p><ol><li>在规范中，计算位于 <a href="https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation" target="_blank" rel="noopener noreferrer">AssignmentExpression 运行时语义这一节中</a>。这一节处理为匿名函数、解构等提供名称的问题</li><li>如果没有解构模式，则会使用 <a href="https://tc39.es/ecma262/#sec-putvalue" target="_blank" rel="noopener noreferrer">PutValue()</a> 完成赋值</li><li>对于属性赋值，<code>PutValue()</code> 调用内部方法 <code>.[[Set]]()</code></li><li>对普通对象，<a href="https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" target="_blank" rel="noopener noreferrer">.[[Set]]()</a> 会调用 <code>OrdinarySet()</code> (它又会调用 <code>OrdinarySetWithOwnDescriptor()</code>)，然后返回结果😂</li></ol><p>🚨 注意的是，在严格模式下，如果 <code>.[[Set]]()</code> 的结果为false， <code>PutValue()</code> 会抛出 <code>TypeError</code></p><p id="2.2"></p><h3 id="_2-2-定义一个属性（defining-a-property）" tabindex="-1">2.2 定义一个属性（Defining a property） <a class="header-anchor" href="#_2-2-定义一个属性（defining-a-property）" aria-hidden="true">#</a></h3><p>定义一个属性的操作实际是通过ECMAScript规范中的 <a href="https://tc39.es/ecma262/#sec-validateandapplypropertydescriptor" target="_blank" rel="noopener noreferrer">下面操作</a> 实现的：📒</p><div class="language-js"><span class="copy"></span><pre><code><span class="line"><span style="color:#82AAFF;">ValidateAndApplyPropertyDescriptor</span><span style="color:#A6ACCD;">(O</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> P</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> extensible</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Desc</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> current): boolean</span></span>
<span class="line"></span></code></pre></div><p>参数含义：</p><ul><li><code>O</code> 表示我们想定义属性的对象。当 <code>O</code> 为 <code>undefined</code> 时，会使用一种特殊的仅验证模式。我们在这里忽略了这种模式。</li><li><code>P</code> 我们想定义的属性key</li><li><code>extensible</code> 指示对象 <code>O</code> 是否可扩展</li><li><code>Desc</code> 是属性描述器，用于指定属性的特性</li><li><code>current</code> 如果自身属性 <code>O[P]</code> 存在的话，它包含属性描述器，否则 <code>current</code> 为 <code>undefined</code></li></ul><p>操作的结果是一个布尔值，表示操作是否成功。失败可能导致不同的后果。一些调用者会忽略这些结果，而有些调用者，比如 <code>Object.defineProperty()</code> ，在结果为 <code>false</code> 时抛出 <code>TypeError</code>。</p><p>下面是这个算法的总结：</p><ul><li>如果 <code>current</code> 是 <code>undefined</code>， 表示属性 <code>P</code> 目前还不存在，必须被创建 <ul><li>如果 <code>extensible</code> 为 <code>false</code>（即对象不可扩展），返回 <code>false</code>，表示属性不能被添加</li><li>否则，检查 <code>Desc</code>，并且创建一个数据属性或者访问器属性</li><li>返回 <code>true</code></li></ul></li><li>如果 <code>Desc</code> 不存在任何字段，返回 <code>true</code>，表示这个操作成功了（因为不需要做任何改变）</li><li>如果 <code>current.[[Configurable]]</code> 是 <code>false</code>（译者注：即对象不可配置）： <ul><li>（<code>Desc</code> 不允许改变除 <code>value</code> 之外的任何特性）</li><li>如果 <code>Desc.[[Configurable]]</code> 存在，它必须和 <code>current.[[Configurable]]</code> 是一样的值，如果不是，则返回 <code>false</code></li><li>对 <code>Desc.[[Enumerable]]</code> 执行相同的检测</li></ul></li><li>接下来：我们 <em>验证</em> 属性描述器 <code>Desc</code>, <code>current</code> 所描述的特性值是否可更改为 <code>Desc</code> 指定的值？如果不能，则返回 <code>false</code>;如果可以，则继续： <ul><li><code>If</code> 描述器是 <em>通用的</em>（即没有指定为数据属性还是访问器属性，译者注：即只指定了 <code>configurable | enumerable</code>），则验证通过，我们继续</li><li><code>Else if</code> 一个描述器指定了数据属性，而另一个指定为了访问器属性： <ul><li>当前属性必须是可以配置的（否者它的特性无法根据需要进行更改）。如果不可配置，则返回 <code>false</code></li><li>将当前属性从数据属性更改为访问器属性，反之亦然。当这样做时，<code>.[[Configurable]]</code> 和 <code>.[[Enumerable]]</code> 的值会保存下来，其它特性得到 <a href="https://exploringjs.com/deep-js/ch_property-attributes-intro.html#property-attributes" target="_blank" rel="noopener noreferrer">默认值</a>（对象值特性为 <code>undefined</code>，布尔值特性为 <code>false</code>）</li></ul></li><li><code>Else if</code> 2个描述器都为数据属性： <ul><li>如果 <code>current.[[Configurable]]</code> 和 <code>current.[[Writable]]</code> 都是 <code>false</code>，则不允许任何改变发生，<code>Desc</code> 和 <code>current</code> 必须指定相同的特性： <ul><li>（因为 <code>current.[[Configurable]]</code> 为 <code>false</code>, <code>Desc.[[Configurable]]</code> 和 <code>Desc.[[Enumerable]]</code> 在先前已经被检验，并且已经为正确值）</li><li>如果 <code>Desc.[[Writable]]</code> 存在，并且是 <code>true</code>，则返回 <code>true</code></li><li>如果 <code>Desc.[[Value]]</code> 存在，并且和 <code>current.[[Value]]</code> 值不相同，则返回 <code>false</code></li><li>没有其他要做的了，返回 <code>true</code> 表示算法成功</li><li>(<em>正常情况下，对不可配置属性，我们只能改变其value，而不能更改其它特性，但是存在一个例外规则，我们可以将可写特性更改为不可写。这个算法会正确的处理这个例外情况</em>)😅</li></ul></li></ul></li><li><code>Else</code> （2个描述器都是访问器属性：） <ul><li>如果 <code>current.[[Configurable]]</code> 是 <code>false</code>，则不允许任何改变。并且 <code>Desc</code> 和 <code>current</code> 必须指定相同特性： <ul><li>（由于 <code>current.[[Configurable]]</code> 已经为 <code>false</code>，<code>Desc.[[Configurable]]</code> 和 <code>Desc.[[Enumerable]]</code> 在之前已经校验，并且拥有正确的值）</li><li>如果 <code>Desc.[[Set]]</code> 存在，它必须和 <code>current.[[Set]]</code> 的值一样，否则返回 <code>false</code></li><li><code>Desc.[[Get]]</code> 执行相同的校验</li><li>没有更多要做的了。返回 <code>true</code> 表示算法成功。</li></ul></li></ul></li></ul></li><li>设置属性 <code>P</code> 的特性为 <code>Desc</code> 指定的值。通过验证，我们能确保所有的改变是允许的</li><li>返回 <code>true</code></li></ul><p id="3"></p><h2 id="_3️⃣-定义和赋值实践（definition-and-assignment-in-practice）" tabindex="-1">3️⃣ 定义和赋值实践（Definition and assignment in practice） <a class="header-anchor" href="#_3️⃣-定义和赋值实践（definition-and-assignment-in-practice）" aria-hidden="true">#</a></h2><p>本节描述属性定义和赋值工作的一些结果。</p><p id="3.1"></p><h3 id="_3-1-只有定义允许使用任何特性创建属性" tabindex="-1">3.1 只有定义允许使用任何特性创建属性 <a class="header-anchor" href="#_3-1-只有定义允许使用任何特性创建属性" aria-hidden="true">#</a></h3><p>如果我们通过<strong>赋值</strong>的方式创建一个自身属性，它总是将 <code>writable</code> &amp; <code>enumerable</code> &amp; <code>configurable</code> 特性设置为 <code>true</code>:</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">dataProp </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">deepEqual</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getOwnPropertyDescriptor</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">dataProp</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">writable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">enumerable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">configurable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p><strong>因此，如果我们想要指定任意特性，我们必须使用 定义 的方式</strong>。</p><p>并且，我们可以在对象字面量中创建 <code>getters</code> &amp; <code>setters</code>，但是我们不能之后通过赋值的方式添加访问器属性，<strong>是的，我们需要使用定义😏</strong>。</p><p id="3.2"></p><h3 id="_3-2-赋值操作符不会改变原型中的属性" tabindex="-1">3.2 赋值操作符不会改变原型中的属性 <a class="header-anchor" href="#_3-2-赋值操作符不会改变原型中的属性" aria-hidden="true">#</a></h3><p>让我们看看下面示例，<code>obj</code> 从 <code>proto</code> 继承了 <code>prop</code> 属性:</p><div class="language-js"><span class="copy"></span><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(prop)</span></span>
<span class="line"></span></code></pre></div><p>我们不能通过给 <code>obj.prop</code> 赋值的方式（破坏性的）改变 <code>proto.prop</code>。这样做只会创建一个新的自身属性：</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br></div><pre><code><span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">deepEqual</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#A6ACCD;">(obj)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  []</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 赋值</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 赋值生效</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 但是我们创建的是自身的属性，尝试覆盖 proto.prop</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 并没有改变原型上的属性</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">deepEqual</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#A6ACCD;">(obj)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(proto</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>这种行为的理由如下：</p><p>原型拥有自己的属性，它的值被所有后代共享。如果我们只想改变它的一个后代中的该属性，我们必须非破坏性的，通过覆盖的形式完成，这样就不会影响到其它后代。</p><p id="3.3"></p><h3 id="_3-3-⭐赋值会调用setters，而定义不会" tabindex="-1">3.3 ⭐赋值会调用setters，而定义不会 <a class="header-anchor" href="#_3-3-⭐赋值会调用setters，而定义不会" aria-hidden="true">#</a></h3><p>定义 <code>obj</code> 的属性 <code>prop</code> 和给它赋值有什么区别呢？</p><p>👩🏻‍🏫 如果我们使用<strong>定义</strong>，则我们的意图要么是为了创建一个自身的（非继承的）属性，要么是为了改变一个自身的属性。因此，<strong>下例中定义会忽略 <code>.prop</code> 继承的setter</strong>:</p><p>🌰</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><div class="highlighted"> </div><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> setterWasCalled </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoGetter</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 🚨 注意这里并没有进行赋值操作 this.prop = x</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">setterWasCalled</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// obj 的原型是 proto</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 原型上的属性</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">propGetter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 定义 obj.prop 添加到对象自身</span></span>
<span class="line"><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  obj</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objData</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 💡 可以看出 原型中的 setter并没有被触发</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(setterWasCalled</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 创建了的自身属性，掩盖了原型上的同名属性</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objData</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>而，如果我们使用 <strong>赋值</strong>，则我们的意图一般是改变<strong>已经存在的东西</strong>，并且 <strong>该改变会通过 setter 处理</strong> 🤔</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> setterWasCalled </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoGetter</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 🚨 注意这里并没有进行赋值操作 this.prop = x</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">setterWasCalled</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// obj 的原型是 proto</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">propGetter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 给 obj.prop 赋值</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objData</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 📚 赋值会触发原型上的 setter</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(setterWasCalled</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 📚 getter仍是激活的</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 因为上面的 setter 中并没有进行赋值</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 所以这里的 obj.prop 仍旧是 &#39;propGetter&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoGetter</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p id="3.3"></p><h3 id="_3-4-继承的只读属性阻止通过赋值创建自己的属性" tabindex="-1">3.4 继承的只读属性阻止通过赋值创建自己的属性 <a class="header-anchor" href="#_3-4-继承的只读属性阻止通过赋值创建自己的属性" aria-hidden="true">#</a></h3><p>假如原型的属性 <code>.prop</code> 是只读的，会发生什么呢？</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><div class="highlighted"> </div><br><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">writable</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>👩🏻‍🏫 <strong>任何从 <code>proto</code> 继承只读属性 <code>.prop</code> 的对象，都不能通过赋值的方式创建自身同名属性</strong></p><p>🌰：</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">throw</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 尝试在对象上使用赋值的方式 创建同名属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;font-style:italic;">^</span><span style="color:#C3E88D;">TypeError: Cannot assign to read only property &#39;prop&#39;</span><span style="color:#89DDFF;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>为什么我们不能赋值呢？理由是，通过创建自身属性的方式覆盖继承的属性，被视作是 <a href="https://exploringjs.com/deep-js/ch_updating-destructively-and-nondestructively.html" target="_blank" rel="noopener noreferrer">非破坏性改变</a> 继承的属性。<strong>按理说，如果一个属性是不可写的，我们不能去覆盖它</strong>。</p><p>🤣 然而，<strong>定义</strong> <code>.prop</code> 仍可正常工作，让我们覆盖它：</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br></div><pre><code><span class="line"><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defineProperty</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  obj</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">prop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">value</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p><em>没有 <code>setter</code> 的访问器属性，也可被认作是只读属性</em>：💡</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">get</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">protoValue</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">throw</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 尝试在对象上使用赋值的方式 创建同名属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">objValue</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;font-style:italic;">^</span><span style="color:#C3E88D;">Uncaught TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter&#39;</span><span style="color:#89DDFF;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>💡 <em>override mistake</em>: 优点和缺点</p><p>事实上，原型链上只读属性阻止赋值，之前称之为 <em>override mistake</em>:</p><ul><li><p>它在ECMAScript5.1 中被引入</p></li><li><p>一方面，这种行为和原型链继承以及setters工作原理保持一致性（所以，这并不是一个错误😅）</p></li><li><p>另一方面，这种行为，在深度冻结全局对象时，会引发不想要的副作用</p></li><li><p>曾尝试改变这种行为，但会破坏Lodash这个库，因此被放弃了 <a href="https://github.com/tc39/ecma262/pull/1320#issuecomment-443485524" target="_blank" rel="noopener noreferrer">PR On GitHub</a></p></li><li><p>背景知识</p><ul><li><a href="https://github.com/tc39/ecma262/pull/1307" target="_blank" rel="noopener noreferrer">PR On GitHub</a></li><li><a href="http://wiki.ecmascript.org/doku.php?id=strawman:fixing_override_mistake" target="_blank" rel="noopener noreferrer">Wiki page onn ECMAScript</a></li></ul></li></ul><p id="4"></p><h2 id="_4️⃣-哪些语言构造使用定义，哪些使用赋值？" tabindex="-1">4️⃣ 哪些语言构造使用定义，哪些使用赋值？ <a class="header-anchor" href="#_4️⃣-哪些语言构造使用定义，哪些使用赋值？" aria-hidden="true">#</a></h2><p>这一节，我们看看语言构造中哪些是使用定义，哪些又是使用赋值的。<strong>我们通过跟踪是否调用了继承的setter来检测使用了哪个操作。</strong> 可以查看上面 <code>3.3</code> 这一小节。</p><p id="4.1"></p><h3 id="_4-1-⭐对象字面量的属性是通过定义添加的" tabindex="-1">4.1 ⭐对象字面量的属性是通过定义添加的 <a class="header-anchor" href="#_4-1-⭐对象字面量的属性是通过定义添加的" aria-hidden="true">#</a></h3><p>👩🏻‍🏫 当我们创建属性通过一个对象字面量，JS总是使用定义（因此，永远不会调用继承的setters）：</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">__proto__</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> proto</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 字面量的方式添加原型</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 通过 `定义` 的方式添加</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 并不会触发原型上的 setter</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p id="4.2"></p><h3 id="_4-2-赋值操作符-总是使用赋值" tabindex="-1">4.2 赋值操作符 = 总是使用赋值 <a class="header-anchor" href="#_4-2-赋值操作符-总是使用赋值" aria-hidden="true">#</a></h3><p>赋值操作符 <code>=</code> 总是使用赋值方式创建或者改变属性</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(proto) </span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 正常赋值</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 💡 可以看出会赋值调用原型setter</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">abc</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 通过解构方式赋值：</span></span>
<span class="line"><span style="color:#A6ACCD;">[obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prop] </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">def</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">def</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p id="4.3"></p><h3 id="_4-3-⭐-公有类字段通过赋值的方式添加" tabindex="-1">4.3 ⭐ 公有类字段通过赋值的方式添加 <a class="header-anchor" href="#_4-3-⭐-公有类字段通过赋值的方式添加" aria-hidden="true">#</a></h3><p>👩🏻‍🏫 即使类中公有字段和赋值语法一样，但是 <strong>它们没有使用赋值的方式创建属性，而是使用定义的方式</strong>（类似对象字面量中的属性）</p><div class="language-js"><span class="copy"></span><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><div class="highlighted"> </div><br><br></div><pre><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument1</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> lastSetterArgument2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop1</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">A prop1 set</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">set</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">prop2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">A prop2 set</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">lastSetterArgument2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">B</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">A</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 和父类设置器中同名属性</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">prop1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">one</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">prop2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">two</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">B</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 📚 公有字段使用 `定义`</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 因此不会触发原型上的同名setter</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">undefined</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 在构造器中，触发 `赋值`</span></span>
<span class="line"><span style="color:#A6ACCD;">assert</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">equal</span><span style="color:#A6ACCD;">(lastSetterArgument2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">two</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p id="5"></p><h2 id="_5️⃣-进一步阅读和本章源码" tabindex="-1">5️⃣ 进一步阅读和本章源码 <a class="header-anchor" href="#_5️⃣-进一步阅读和本章源码" aria-hidden="true">#</a></h2><ul><li><a href="https://exploringjs.com/impatient-js/ch_proto-chains-classes.html#prototype-chains" target="_blank" rel="noopener noreferrer">Property chains - JS for impatient programmers</a></li><li><a href="https://mail.mozilla.org/pipermail/es-discuss/2012-July/024227.html" target="_blank" rel="noopener noreferrer">es-discuss mailing list</a> 当ES只拥有数据属性，并且ES代码无法操作属性特性时，赋值和定义之间的区别就不是很重要了</li></ul><h2 id="_6️⃣-小结（译者注）" tabindex="-1">6️⃣ 小结（译者注） <a class="header-anchor" href="#_6️⃣-小结（译者注）" aria-hidden="true">#</a></h2><ol><li>赋值的主要目的是什么？ 做出改变，支持setters（和继承密切相关）</li><li>定义的主要目的是什么？ 创建一个自身的属性，忽略继承的setters</li><li>理论上，赋值和定义在ECMAScript规范中的算法实现过程</li><li>定义可以添加任何属性特性</li><li>赋值不会改变原型链上的同名属性</li><li>赋值会调用原型上的同名 setter，而定义不会（🚀）</li><li>继承只读属性，赋值和父类同名的属性，会抛出错误；而定义不会</li><li>对象字面量属性是通过定义形式创建的（🚀）</li><li><code>=</code> 操作符总是执行赋值操作</li><li>类的公有字段通过定义创建；而类构造器中的属性通过赋值创建（🚀）</li></ol><p>2022年07月19日23:36:28</p></div></div></main><footer class="VPDocFooter" data-v-79ca2460 data-v-04568844><div class="edit-info" data-v-04568844><div class="edit-link" data-v-04568844><a class="VPLink link edit-link-button" href="https://github.com/jamessawyer/deep-javascript-cn/edit/main/docs/4/Properties-assignment-vs-definition.md" target="_blank" rel="noopener noreferrer" data-v-04568844 data-v-5704c677><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-04568844><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 在GitHub编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-04568844><p class="VPLastUpdated" data-v-04568844 data-v-0ce8c960>Last updated: <time datatime="2022-07-25T13:16:33.000Z" data-v-0ce8c960></time></p></div></div><div class="prev-next" data-v-04568844><div class="pager" data-v-04568844><a class="pager-link prev" href="/deep-javascript-cn/4/Protecting-objects-from-changed.html" data-v-04568844><span class="desc" data-v-04568844>Previous page</span><span class="title" data-v-04568844>11.保护对象更改</span></a></div><div class="has-prev pager" data-v-04568844><a class="pager-link next" href="/deep-javascript-cn/4/Enumerability-of-Properties.html" data-v-04568844><span class="desc" data-v-04568844>Next page</span><span class="title" data-v-04568844>13.属性的可枚举性</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><!----><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"2_a-detailed-look-at-global-variables.md\":\"f49a63f6\",\"2_environments-under-the-hood-of-variables.md\":\"4b555357\",\"2_the-destructuring-algorithm.md\":\"d10bb3c8\",\"2_type-coercion-in-javascript.md\":\"a1c9d389\",\"4_enumerability-of-properties.md\":\"4e3eb04e\",\"4_properties-assignment-vs-definition.md\":\"ad93b466\",\"4_property-attributes-an-introduction.md\":\"6944ea75\",\"4_protecting-objects-from-changed.md\":\"9a762796\",\"5_techniques-for-instantiating-classes.md\":\"7b977339\",\"7_metaprogramming-with-proxies.md\":\"cd96fead\",\"index.md\":\"31614216\"}")</script>
    <script type="module" async src="/deep-javascript-cn/assets/app.1f1ae7ae.js"></script>
    
  </body>
</html>